из get_file_session.cpp:

// Схема отправки данных.
//
// Для чтения с дисков используем потоки из reader_thread_pool.
// Ставим задачу readTask в выбранный поток. Сначала нужно сформировать
// и отправить заголовок mp4. Считаем его небольшим и отправляем
// за одну итерацию. При этом поток чтения занимаем на длительное время
// (время считывания данных с диска для первого прохода).
// При текущем построении данные берём из файлов с видеоданными,
// а не из какого-либо внешнего индекса.
//
// Эффективнее было бы хранить
// заголовки файлов в том же формате mp4 и формировать новые заголовки
// из уже существующих. Для этого потребуется формировать псевдозаголовки
// специального формата для ещё не завершённых файлов. Эти псевдозаголовки
// будут играть роль индекса по видео данным. А сами видеоданные
// можно разбить на чанки, один чанк - один кадр. Это позволит
// вставлять в видеоданные разделители кадров, чтобы не терять данные,
// для которых не был записан заголовок.
// ...в реальности точность записи будет ограничена на уровне ОС.
// flush буферов по умолчанию в Linux - порядка 5 секунд.
// Т е в случае отказа будет потеряно до 5 секунд видео.
// ...можно было бы писать несколько малых подблоков таблиц mp4,
// (лучше - входных данных для построения таблиц), делая flush
// с небольшим интервалом.
//
// Второй проход - "тяжёлый" по трафику в сторону клиента. Здесь включаем
// ограничитель - состояние отправки данных клиенту (состояние Sender'а).
// Тут есть проблема: отправка данных клиенту выполняется в одтельном потоке
// через DeferredConnectionSender. Во-первых, это неэффективно. Во-вторых,
// теряется возможность немедленно узнать о переполнении буферов отправки
// сетевого стека. Последняя возможность критически важна для упрощения
// логики чтения и отправки данных. Это означает, что отправлять данные
// нужно немедленно, используя для этого ImmediateConnectionSender.
//
// Затруднение состоит в том, что соединение обслуживается через
// HttpService, который использует DCS (!_неверно_: он как раз использует
// ImmediateConnectionSender).
//
// На самом деле, в любом случае интересует SoftBarrier Sender'а, т е
// наполнение его очереди отправки независимо от состояния стека TCP.
// Т е подойдут и DCS, и ICS, но sendMessage() должен возвращать
// состояние Sender'а на момент завершения постановки сообщения в очередь.
//
// Существует проблема синхронизации уведомлений об изменении состояния
// Sender'а с потоком отправки данных. Основной сценарий работы:
//   * readTask отправляет порцию данных;
//   * Sender либо переходит в >=Overloaded, либо остаётся Ready;
//   * если Sender остался ready, то задействуем логику ограничения
//     исходящего потока данных (по трафику);
//   * если Sender стал overloaded, то он сообщит либо не сообщит
//     об этом немедленно (кодом возврата sendMessage()), и поставит
//     в очередь уведомление об изменении состояния;
//   * На следующей итерации отправки, которая может быть инициирована
//     в любой момент, возможна гонка по отложенному уведомлению об
//     изменении состояния Sender'а. Проблемный случай - ложный
//     репорт о готовности к отправке. Прийти может уведомление,
//     которое было поставлено в очередь ещё до того, как была
//     отправлена последняя порция данных.
//
// Выход - перед отправкой данных при заблокированном Sender'е
// проверять его реальное состояние, а асинхронные уведомления
// об изменении состояния Sender'а воспринимать как приблизительные
// указания.

