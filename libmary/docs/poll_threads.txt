Логика многопоточной работы привязана к особенностям потоков данных, проходящих
через сервер.

Основная особенность потокового медиасервера - поддержание продолжительных
сеансов связи с передачей больших объёмов данных.

Источник данных ---> Сервер ---> Стек TCP в ядре ---> Клиент

Задача сервера - максимально эффективно передавать данные, полученные от
источника, в ядро.

При получении данных от источника встаёт задача группировки входящих данных,
чтобы обрабатывать эти данные крупными порциями (в тех случаях, когда допустимо
введение небольшой задержки при передаче данных, порядка 300 мс).

Неэффективные места в сервере:
* Способ хранения данных в страницах не более одного аудио/видеосообщения на
  страницу. Повышается расход памяти, ухудашется локальность размещения данных.
* Размножение данных непосредственно в момент их получения, в том же потоке.
  Нарушается принцип распределения нагрузки по потокам: наиболее тяжёлая часть
  обоработки данных - формирование конечных RTMP-сообщений - выполняется
  в одном потоке, съедая ресурсы, доступные для тяжёлой подготовки видеоданных.
* Отсутствие возможности группировки клиентов, получающих видео из одного
  и того же источника. В результате вычислительные ресурсы используются не самым
  эффективным образом.

В текущей реализации Moment все объекты независимы и асинхронны, за исключением
привязки логики получения данных к домену синхронизации используемой PollGroup.

Абсолютизируя возможности по ограничению использования механизмов синхронизации
при взаимодействии между объектами, получим полную привязку каждого объекта
к своему потоку исполнения. При выполнении любого действия с объектом,
находящимся в потоке исполнения, отличном от текущего, нужно отправить этому
объекту сообщение.

На первом этапе единственной операцией, представляющей интерес с точки зрения
оптимизации, является передача аудио/видеокадра от источника потребителю.

Допустим, что необходимо передать сообщение (видеокадр) M из принимающего потока
(потока gstreamer) множеству клиентов (4000 клиентов). Клиенты обслуживаются
в четырёх отдельных потоках, по 1000 клиентов на поток. Сейчас передача
реализована следующим образом:
    1. Получаем от источника один видеокадр;
    2. Для видеопотока (VideoStream) выполняем операцию informAll, при этом
       по одному производится обход всех получателей и добавляются сообщения
       в очередь отправки для каждого соединения.

Более детально:
    1. Получили видеокадр M;
    2. Начинаем обход получателей - подписчиков VideoStream.
       Далее для каждого подписчика, по очереди:
    3. Получаем блокировку Informer'а;
    4. Получаем CodeRef для WeakCodeRef, связанного с подписчиком;
    5. Разблокируем Informer;
    6. Захватываем мьютекс клиентской сессии mod_rtmp;
    7. Определяем, как далее поступить с сообщением (передать);
    8. Разблокируем клиентскую сессию mod_rtmp;
    9. Блокируем RtmpConnection, формируем сообщение, при этом пользуясь
       блокировкой PagePool;
   10. Блокируем DCS и ставим сообщение в очередь отправки.
   11. В момент обработки очереди отправки - блокируем очередь, формируем
       writev-вектор и выполняем вызов writev.

Тут сплошные блокировки и избыточная (с точки зрения логики передачи данных)
синхронизация. Можно ли предложить схему более простую с точки зрения
синхронизации?

Основная цель - получение линейно масштабируемой по процессорным ядрам схемы
передачи данных. По текущей схеме считаю, что она масштабируется плохо.
Превзойти однопоточный режим работы (mt-unsafe сборку сервера), изменив схему
передачи данных, вряд ли удастся. Превзойти mt-safe сборку - возможно.

Вариант:
    1. Получили видеокадр M;
    2. Определяем, по каким потокам нужно распределить сообщение M и ставим
       это сообщение в очередь уведомления для каждого из этих потоков.
       Сообщения по потокам можно раскладывать в один выбранный момент, перед
       входом в epoll. Для потока gstreamer - сразу;
    3. В получающих потоках в некоторый момент разбираем очередь входящих
       сообщений. При этому уведомление о получении видеоданных можно считать
       синхронизированной операцией;
    4. Обращения к DCS и работу с очередью отправки считаем не требующей
       синхронизации, т к работа видётся только в рамках одного потока.

Дополнительный плюс: меньше синхронизации - меньше ошибок. Такая схема более
точно отражает реальные потребности в асинхронности каждого элемента цепочки
передачи. Часто асинхронность навязывается рядом мелких и редких операций,
при том, что основные тяжёлые операции могли бы выполняться без синхронизации.
Использование передачи сообщений между потоками позволяет избежать такого
навязывания избыточной синхронизации.

