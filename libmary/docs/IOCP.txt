Ввод/вывод через IOCP.

Нужно определиться, как гарантировать доступность OVERLAPPED и буферов
при асинхронном I/O под Windows.

Интерес представляет момент удаления объектов Connection, Sender, Receiver
и момент удаления IocpPollGroup (далее - IOCP).

Можно считать, что Connection, Sender и Receiver удаляются только одновременно.

Connection нужно удалять обязательно, т к CloseHandle используется для
cancellation. Поэтому Overlapped выносится в отдельный вспомогательный объект.

Моментов для удаления у Overlapped два: когда удаляется Connection без
незавершённых операций и когда завершается последняя операция.

Обобщённый вариант для Overlapped - подсчёт ссылок. Новая операция - новая
ссылка, плюс одна ссылка у Connection.

read() -> pending -> ref()
inputComplete -> unref()
    В этом случае unref должна делать IOCP-группа. Т е это unref
    на каждое уведомление.

Избавиться от синхронизации можно через выделенный lock: вынести mutex
Sender'а и Receiver'а в структуру, связанную с Overlapped. Потребуется
разделение read и write операций, два мьютекса. Станет невозможна
независимая проверка завершения операций чтения и записи.
Правильное решение по синхронизации - отправлять данные только из
потока, к которому привязано соединение.

Следовательно, использую OverlappedBlock и счётчик ссылок на него.

А если IOCP разрушается первой? Уведомления не будут получены. В этом случае
нет способа отличить ссылки от незавершенных операций и ссылку от неразрушенного
Connection.
    - удалять IOCP в собственном потоке так, чтобы не требовалась
      дополнительная синхронизация. А сейчас просто допускать потерю
      ссылок на OverlappedBlock.

