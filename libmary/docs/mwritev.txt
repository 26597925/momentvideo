11.08.19
Тестирую mwritev.

Сборка -O3, epoll

frame_duration = 40
frame_size = 0

-r в 10 раз больше, чем -n

[cpu moment]/[cpu] rtmptool

OLD   Полностью старая логика;
OLDMW Эмуляция writev через mwritev, со старой логикой отправки;
NEW   Новая логика отправки с mwritev.

1000 клиентов:
OLD   36/29
OLDMW 38/30
NEW   31/27

2000 клиентов:
OLD   70/55
OLDMW 75/60
NEW   61/55

-> течёт память в rtmptool?

frame_duration = 40
frame_size = 2500

1000 клиентов:
OLD   55/40
OLDMW 60/45,
      с mwritevSingle: 60/47,
      с mwritevSingle, завязанным на sys_writev: 61/44
          аналогично с mwritev, завязанным на sys_writev
NEW   46/29
      46/30 с mwritev, завязанным на sys_writev

С использованием poll: NEW 45/39

------


О производительности.

11.08.20
Реализовал mwritev и выполнил первую реализацию логики отправки данных
с использованием mwritev. Результат скромный: при некоторых вариантах нагрузки
15%-й прирост производительности.

Судя по результатам профилирования (пока только sysprof), большую часть времени
moment занимается обслуживанием очереди отправки сообщений. Вполне логично,
учитывая, что это наиболее сложная часть сервера.

